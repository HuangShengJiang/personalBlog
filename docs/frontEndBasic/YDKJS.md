---
title: You Don't Know JS(YDKJS)
---
## 契机
《你不知道的Javascript》这本书的评价相当的高，某日闲逛github发现这本书的原著（Star数排行貌似还是前十呢）。想着一边看英文文档一边学习新知识也不错，便果断转向在线阅读这本书（嘻嘻，主要还是因为在线看免费~）。结果一看就入迷了，书里写的很多是我不知道或者说是我一直以来都存在误解的知识点。所以想着要把书里一些有趣的东西记录下来。

## Scope、Engine、Compiler
1. Scope(作用域) 维护一个已经定义好的变量查找清单，并强制让 执行中的程序 遵循一系列规则 以获取变量；

2. engine(JS 引擎) 配合作用域执行 已经编译过的可执行代码；

3. compiler(编译器) 将程序员编写的JS代码 编译为 可执行代码；

## RHS查询与LHS查询
1. 在代码执行过程中：

如果JS引擎查找某个变量是为了给这个变量分配内存空间存放数据（也可以理解为给变量赋值），那么我们可以称这种查找为LHS查询(Left-Hand-Side Look-up) 

如果JS引擎查找某个变量是为了获得这个变量内存空间中的数据，那么我们可以称这种查找为RHS查询(Right-Hand-Side Look-up)

2. 查找变量的规则：

    1. 从变量当前的`作用域`开始查找该变量，如果有，则直接返回这个变量所指向的值；
    如果没有，则查询包裹当前作用域的`外层作用域`。如果外层作用域还是没有这个变量，则继续往更外层的作用域进行查找；
    一直查询到全局（顶层作用域）
    
    2. 如果依旧还没有找这个变量，这时`LHS查询`和`RHS查询`的表现会出现差异。
    
    先说`LHS查询`，在非严格模式（strict mode）下，LHS查询会悄咪咪的把这个变量定义到全局（顶层作用域）；而在严格模式下，LHS查询会报一个引用错误 `ReferenceError`；
    
    而`RHS查询`则是直接报一个引用错误 `ReferenceError`；

大家看看下面的代码：
```javascript
function foo(a) {
	console.log( a );
	b = a;
}

foo( 2 ); // 4
```
在上面的例子中，JS引擎一直在配合作用域(scope)在做`LHS查询`和`RHS查询`。

`LHS查询`分别在以下操作中使用到：
* 调用 `foo`函数时查找参数`a`并将数值`2`赋值参数`a`；
* 查找变量`b`并将已经找到的变量`a`的值赋予变量`b`；

`RHS查询`分别在以下操作中使用到：
* 调用 `foo`函数前先查找变量`foo`的指向；
* 在console.log调用前查找变量`console`和变量`log`的指向；
* 调用console.log时查找变量`a`的指向；
* 调用 `b=a`时，查找 变量 `a`的指向；



## 参考链接
1. [YDKJS（Scope & Closures）-原文地址](https://github.com/getify/You-Dont-Know-JS/blob/master/scope%20%26%20closures/ch1.md)